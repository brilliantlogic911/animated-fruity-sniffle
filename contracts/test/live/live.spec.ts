import { expect } from "chai";
import { ethers } from "hardhat";

const ERC2981_INTERFACE_ID = "0x2a55205a";

function requireEnv(name: string): string {
  const v = process.env[name];
  if (!v) throw new Error(`Missing required env var ${name}`);
  return v;
}

describe("Live read-only checks on Base mainnet", function () {
  const fruitAddr = process.env.STATICFRUIT_ADDR;
  const seedsAddr = process.env.STATICSEEDS_ADDR;
  const sampleTokenIdStr = process.env.STATICFRUIT_SAMPLE_TOKENID || "1";
  const sampleTokenId = BigInt(sampleTokenIdStr);

  // Only run if env vars are present
  const canRun = !!fruitAddr && !!seedsAddr;

  (canRun ? describe : describe.skip)("StaticFruitDeliciousAnimated (ERC721 + ERC2981)", function () {
    it("attaches and validates basic metadata and ERC-2981 support", async () => {
      const nft = await ethers.getContractAt("StaticFruitDeliciousAnimated", requireEnv("STATICFRUIT_ADDR"));
      const name = await nft.name();
      const symbol = await nft.symbol();

      expect(name).to.be.a("string").and.to.have.length.greaterThan(0);
      expect(symbol).to.be.a("string").and.to.have.length.greaterThan(0);

      const supports = await nft.supportsInterface(ERC2981_INTERFACE_ID);
      expect(supports).to.eq(true);

      // Royalty info read-only probe with 1 ether sale price
      const salePrice = ethers.parseEther("1");
      const [receiver, amount] = await nft.royaltyInfo(sampleTokenId, salePrice);
      expect(receiver).to.properAddress;
      expect(amount).to.be.gte(0n);
      expect(amount).to.be.lte(salePrice);
    });

    it("returns a valid data:application/json base64 tokenURI and a bounded deliciousness score", async () => {
      const nft = await ethers.getContractAt("StaticFruitDeliciousAnimated", requireEnv("STATICFRUIT_ADDR"));

      // tokenURI
      const uri = await nft.tokenURI(sampleTokenId);
      expect(uri.startsWith("data:application/json;base64,")).to.eq(true);

      // deliciousnessOf within [0..100]
      const score: bigint = await nft.deliciousnessOf(sampleTokenId);
      expect(score).to.be.gte(0n);
      expect(score).to.be.lte(100n);
    });
  });

  (canRun ? describe : describe.skip)("StaticSeeds (ERC1155)", function () {
    it("validates sign & tokenId mappings and public constants", async () => {
      const seeds = await ethers.getContractAt("StaticSeeds", requireEnv("STATICSEEDS_ADDR"));

      // Check a couple of known mappings
      const ariesId: bigint = await seeds.getTokenId("aries");
      expect(ariesId).to.eq(1n);

      const sign1 = await seeds.getSign(1);
      expect(sign1).to.eq("aries");

      // Public constants via autogenerated getters
      const price: bigint = await seeds.MINT_PRICE();
      const cap: bigint = await seeds.MAX_SUPPLY_PER_SIGN();
      expect(price).to.be.gt(0n);
      expect(cap).to.be.gt(0n);

      // URI should include the tokenId string
      const u1 = await seeds.uri(1);
      expect(u1).to.include("1");
    });
  });
});